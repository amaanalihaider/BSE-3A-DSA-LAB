#include<iostream>
#include <algorithm>  // for std::all_of
#include <cctype> 
#include<string>

using namespace std;
//// Forward Declarations 
//void insertAtHead(Node*& head, int data);
//void insertionAtTail(Node* head, int data);
//void insertAtMiddle(Node* head, int position, int data);
//void insertAtAnyPosition(Node*& head, int position, int data);
//void displayLinkedList(Node* head);
//void deleteAtHead(Node*& head);
//void deleteFromAnyPosition(Node*& head, int position);
//void deleteFromTail(Node*& head);
//void menU();
// bool validInput


class Node {
public:
    Node* next;
    int data;

    Node(int data) {
        next = NULL;
        this->data = data;
    }
};

class LinkedList {
public:
    Node* head;
    // Constructor
    LinkedList() {
        head = NULL;
    }


    // Insertion at Head
    void insertAtHead(int data)
    {
        // create a New Node
        Node* temp = new Node(data);
        temp->next = head;
        head = temp;
    }

    void insertionAtTail(int data) {

        // Create a temporary Node 
        if (head == NULL) {
            // If head is NULL, use insertAtHead to insert the first node
            insertAtHead(data);
            return;
        }

        Node* temp = head;
        while (temp->next != NULL) {
            temp = temp->next;
        }
        // Now You have reached a Spot
        Node* endNode = new Node(data);
        temp->next = endNode;
        endNode->next = NULL;
    }

    void insertAtMiddle(int position, int data) {

        // Create a temp Node to Iterate through
        int count = 1;
        Node* temp = head;

        // Traverse the list until you reach (position - 1)
        while (count < position - 1 && temp != NULL) {
            temp = temp->next;
            count++;
        }

        // Check if position is valid (temp != NULL)
        if (temp != NULL) {
            // Now, temp is at the (position - 1), so we can insert the new node
            Node* middleNode = new Node(data);
            middleNode->next = temp->next;
            temp->next = middleNode;
        }
        else {
            // Position is out of bounds
            cout << "Position is out of bounds!" << endl;
        }
    }

    void insertAtAnyPosition(int position, int data) {

        if (position < 1) {
            cout << " The Position has to be Greater than or equal to 1" << endl;
            return;
        }

        // Head insertion
        if (position == 1) {
            insertAtHead(data);
            return;
        }

        // Middle insertion 
        // Means Position is greater than 1
        Node* temp = head;
        int count = 1;

        while (count < position - 1 && temp != NULL) {
            // keep incrementing
            temp = temp->next;
            count++;
        }

        // Check if temp != NULL
        if (temp != NULL) {
            Node* middleNode = new Node(data);
            middleNode->next = temp->next;
            temp->next = middleNode;
        }
        else {
            cout << " Position is out of Bounds!" << endl;
        }
    }
    // Display

    void displayLinkedList() {
        Node* temp = head;
        while (temp != NULL) {
            cout << temp->data << " ";
            temp = temp->next;
        }
        cout << endl;


    }

    // Menu
   

    // Deletion Functions

    void deleteAtHead() {

        if (head == NULL) {
            cout << "It's Empty " << endl;
            return;
        }

        Node* temp = head;
        head = head->next;
        delete temp;
    }


    void deleteFromTail() {

        if (head == NULL) {
            cout << " The List is Empty " << endl;
            return;
        }

        if (head->next == NULL) {
            delete head;
            head = NULL;
            return;
        }

        Node* previous = NULL;
        Node* current = head;

        while (current->next != NULL) {
            previous = current;
            current = current->next;
        }
        if (current != NULL) {
            previous->next = NULL;
            delete current;
        }
    }

    void deleteFromAnyPosition(int position) {
        if (head == NULL || position < 1) {
            cout << "Invalid position or empty list!" << endl;
            return;
        }

        if (position == 1) {
            deleteAtHead();
            return;
        }

        Node* temp = head;
        Node* prev = NULL;
        int count = 1;

        while (count < position && temp != NULL) {
            prev = temp;
            temp = temp->next;
            count++;
        }

        if (temp != NULL) {
            prev->next = temp->next;
            delete temp;
        }
        else {
            cout << "Position is out of bounds!" << endl;
        }
    }

    int getPeek() {

        if (head == NULL) {
            cout << "Its Empty There is No peek " << endl;
            return -1;
        }
        return head->data;

    }

    bool isEmpty() {
        if (head == NULL) {
            return true;
        }
        else {
            return false;
        }

    }

};
void Menu() {

    cout << " ----Menu----- " << endl;
    cout << "1. Create a Stack  " << endl;
    cout << "2. Create a Queues  " << endl;
    cout << "3. Create a Double Ended Queue " << endl;
    cout << "4. E or e to Exit" << endl;

}
void stackMenu() {
    // List of operations
    cout << "1.Push Element " << endl;
    cout << "2.Pop Element " << endl;
    cout << "3.View Peak Element " << endl;
    cout << "4.Display Stack " << endl;
}
void queueMenu() {

    // List of Operations 
    cout << "1.Insert Element " << endl;
    cout << "2.Remove Element " << endl;
    cout << "4.Display Queue " << endl;

    
}
void dequeMenu() {

    // List of Operations
    cout << "1.Push Element At Front " << endl;
    cout << "2.Pop Element At Front " << endl;
    cout << "1.Push Element At Rear " << endl;
    cout << "2.Pop Element At Rear " << endl;
    cout << "4.Display Deque " << endl;
}
bool validInput(string input) {
    // All the Number Entered are Digit
    if (all_of(input.begin(), input.end(), ::isdigit)) {
        return true;
    }
    else {
        return false;
    }
}
// Stack Using LinkedList
class Stack {
public:
    LinkedList list;

    Stack() {}


    // Functions
    void push(int data) {
        list.insertAtHead(data);
    }
    void pop() {
        list.deleteAtHead();
    }
    void getPeak() {
        list.getPeek();
    }
    bool isEmpty() {
        if (list.isEmpty()) {
            return true;

        }
        else {
            return false;
        }
    }
    void display() {
        list.displayLinkedList();
    }
};

// Queue Using a Linked list 
class Queue {
public:

    LinkedList list;

    Queue() {}

    // Functions
    // Insertion  at head and deleteion from tail
    void insert(int data) {
        list.insertAtHead(data);
    }
    void remove() {
        list.deleteFromTail();
    }
    void display() {
        list.displayLinkedList();
    }

};

// Dequeue using Linked List
class Deque {
public:
    LinkedList list;

    Deque() {}

    // functions 

    void insertAtFront(int data) {
        list.insertAtHead(data);
    }

    void popAtFront() {
        list.deleteAtHead();
    }
    void insertAtRear(int data) {
        list.insertionAtTail(data);
    }
    void popAtRear() {
        list.deleteFromTail();
    }
    void display() {
        list.displayLinkedList();
    }


};


int main() {
    string choice;

    do {
        Menu();
        cout << "Enter choice to proceed further: " << endl;
        getline(cin, choice);  

        if (!(choice == "1" || choice == "2" || choice == "3")) {
            cout << "You have made an invalid choice. Please re-enter again." << endl;
        }

    } while (!(choice == "1" || choice == "2" || choice == "3"));

    cout << "You selected: " << choice << endl;

    if (choice == "1") {
        // stacks Implementation
        stackMenu();
        Stack Obj;
        
   }
    else if (choice == "2") {
        // Queues Implementation

    }
    else if (choice == "3") {
        // Double ended Queue Implementation
    }
    else {
        // Wrong choice mate
    }


    return 0;
}

   /* Node* head = NULL;

    LinkedList l1;
    Stack s1;
    cout << " Checking stack Behaviour " << endl;
    s1.push(1);
    s1.push(2);
    s1.push(3);
    s1.push(4);
    s1.push(5);
    s1.pop();
    s1.display();

    cout << endl;
    cout << " Checking Queue Behaviour " << endl;

    Queue Q1;
    Q1.insert(1);
    Q1.insert(2);
    Q1.insert(3);
    Q1.insert(4);
    Q1.insert(5);
    Q1.remove();
    Q1.display();


    cout << endl;
    cout << " Checking DEQUE Implementation " << endl;

    Deque dq;
    dq.insertAtFront(1);
    dq.insertAtRear(2);
    dq.insertAtFront(3);
    dq.insertAtRear(4);

    dq.display();
    cout << " pop at front " << endl;
    dq.popAtFront();
    dq.display();
    cout << " pop at rear " << endl;
    dq.popAtRear();
    dq.display();
    return 0;*/
