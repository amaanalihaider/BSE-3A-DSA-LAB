/*
  ============================================================
  Program Logic and Approach:
  ============================================================
  This program implements Huffman Coding for lossless data compression.
 
  1. First, the program accepts an input string from the user and calculates
     the frequency of each character.
 
  2. A Min-Heap (priority queue) is then used to build the Huffman Tree
     based on character frequencies.
 
  3. Once the tree is built, the Huffman codes for each character are
     generated by traversing the tree (assigning '0' for left traversal and
     '1' for right traversal).
 
  4. The program allows encoding of the input string based on the generated
     Huffman codes.
 
  5. It then decodes the encoded string using the same Huffman Tree and checks
     if the decoded string matches the original string.
 
  6. Finally, the program calculates the size difference between the original
     and the encoded string to demonstrate compression.
 
  The program includes a menu-based interface to allow users to interact with
  the program, including displaying the frequency table, Huffman codes,
  encoding, decoding, and calculating compression ratios.
 
  ============================================================
  Test Cases:
  ============================================================
  Test Case 1: "huffman coding is fun"
  Expected Output:
  - Frequency table for characters like 'h', 'u', 'f', etc.
  - Generated Huffman codes for each character.
  - Encoded string based on Huffman codes.
  - Decoded string should match the input string.
  - Compression ratio displayed.
 
  Test Case 2: "hello world"
  Expected Output:
  - Frequency table for characters like 'h', 'e', 'l', etc.
  - Generated Huffman codes for each character.
  - Encoded string based on Huffman codes.
  - Decoded string should match the input string.
  - Compression ratio displayed.
  */



#include <iostream>
#include <string>
#include <queue>
#include <unordered_map>
#include <vector>
#include <limits> // Include this header for numeric_limits

using namespace std;

// (Rest of the code remains unchanged)


// Define the Node class for Huffman Tree
class Node {
public:
    char character;
    int frequency;
    Node* left;
    Node* right;

    // Constructor for leaf nodes (characters)
    Node(char c, int freq) : character(c), frequency(freq), left(nullptr), right(nullptr) {}

    // Constructor for internal nodes (combined nodes)
    Node(Node* l, Node* r) : character(0), frequency(l->frequency + r->frequency), left(l), right(r) {}

    // Comparison operator to be used in the priority queue (min-heap)
    bool operator>(const Node& other) const {
        return frequency > other.frequency;
    }
};

// Function to generate the Huffman codes by traversing the tree
void generateHuffmanCodes(Node* root, const string& code, unordered_map<char, string>& huffmanCodes) {
    if (!root) return;

    if (root->character != 0) {
        huffmanCodes[root->character] = code;
    }

    generateHuffmanCodes(root->left, code + "0", huffmanCodes);
    generateHuffmanCodes(root->right, code + "1", huffmanCodes);
}

// Function to encode the string using Huffman codes
string encodeString(const string& input, const unordered_map<char, string>& huffmanCodes) {
    string encoded = "";
    for (char c : input) {
        encoded += huffmanCodes.at(c);
    }
    return encoded;
}

// Function to decode the binary string back into the original string
string decodeString(const string& encoded, Node* root) {
    string decoded = "";
    Node* currentNode = root;
    for (char bit : encoded) {
        currentNode = (bit == '0') ? currentNode->left : currentNode->right;

        if (currentNode->character != 0) {
            decoded += currentNode->character;
            currentNode = root;
        }
    }
    return decoded;
}

// Function to display the menu
void displayMenu() {
    cout << "\n==================== MENU ====================" << endl;
    cout << "1. Input a String" << endl;
    cout << "2. Display Frequency Table" << endl;
    cout << "3. Display Huffman Codes" << endl;
    cout << "4. Encode the String" << endl;
    cout << "5. Decode the Encoded String" << endl;
    cout << "6. Compare Size (Compression Ratio)" << endl;
    cout << "7. Exit" << endl;
    cout << "==============================================" << endl;
    cout << "Choose an option: ";
}

// Function to validate the user's choice
int getValidMenuChoice() {
    int choice;
    while (true) {
        cin >> choice;
        if (cin.fail() || choice < 1 || choice > 7) {
            cin.clear(); // Clear the error flag
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ignore invalid input
            cout << "Invalid choice. Please enter a valid option (1-7): ";
        } else {
            cin.ignore(); // To ignore the newline character
            break;
        }
    }
    return choice;
}

// Function to get valid input string
bool getValidInputString(string& input) {
    cout << "Enter a string to encode using Huffman Coding: ";
    getline(cin, input);

    if (input.empty()) {
        cout << "Error: The input string cannot be empty!" << endl;
        return false;
    }
    return true;
}

int main() {
    string input;
    unordered_map<char, int> frequency;
    unordered_map<char, string> huffmanCodes;
    Node* root = nullptr;
    string encodedString = "";

    while (true) {
        displayMenu(); // Show the menu

        int choice = getValidMenuChoice(); // Get a valid menu choice

        switch (choice) {
            case 1: {
                // Input a string from the user with validation
                if (getValidInputString(input)) {
                    // Build the frequency table
                    frequency.clear();
                    for (char c : input) {
                        frequency[c]++;
                    }
                    cout << "String input successful!" << endl;
                }
                break;
            }

            case 2: {
                // Display frequency table
                if (input.empty()) {
                    cout << "Error: No string has been entered yet!" << endl;
                    break;
                }
                cout << "\nFrequency Table:\n";
                for (const auto& entry : frequency) {
                    cout << "Character: " << entry.first << " | Frequency: " << entry.second << endl;
                }
                break;
            }

            case 3: {
                // Generate Huffman Codes
                if (frequency.empty()) {
                    cout << "Error: No string has been entered yet!" << endl;
                    break;
                }

                // Build the Huffman tree using a min-heap (priority queue)
                priority_queue<Node*, vector<Node*>, greater<Node*>> minHeap;
                for (const auto& entry : frequency) {
                    minHeap.push(new Node(entry.first, entry.second));
                }

                while (minHeap.size() > 1) {
                    Node* left = minHeap.top(); minHeap.pop();
                    Node* right = minHeap.top(); minHeap.pop();
                    minHeap.push(new Node(left, right));
                }

                // The root of the Huffman tree
                root = minHeap.top();

                // Generate Huffman codes
                huffmanCodes.clear();
                generateHuffmanCodes(root, "", huffmanCodes);

                // Display the Huffman codes
                cout << "\nCharacter, Frequency, Huffman Code:\n";
                for (const auto& entry : huffmanCodes) {
                    cout << entry.first << " | " << frequency[entry.first] << " | " << entry.second << endl;
                }
                break;
            }

            case 4: {
                // Encode the string
                if (huffmanCodes.empty()) {
                    cout << "Error: No Huffman codes generated yet!" << endl;
                    break;
                }

                encodedString = encodeString(input, huffmanCodes);
                cout << "\nOriginal String: " << input << endl;
                cout << "Encoded String: " << encodedString << endl;
                break;
            }

            case 5: {
                // Decode the encoded string
                if (encodedString.empty()) {
                    cout << "Error: No encoded string available!" << endl;
                    break;
                }

                string decodedString = decodeString(encodedString, root);
                cout << "\nDecoded String: " << decodedString << endl;
                cout << "Is the decoded string equal to the original string? " 
                     << (decodedString == input ? "Yes" : "No") << endl;
                break;
            }

            case 6: {
                // Compare the size and calculate compression ratio
                if (input.empty()) {
                    cout << "Error: No string has been entered yet!" << endl;
                    break;
                }

                if (encodedString.empty()) {
                    cout << "Error: No encoded string available!" << endl;
                    break;
                }

                int originalSize = input.size() * 8; // Original size in bits (1 character = 1 byte)
                int encodedSize = encodedString.size(); // Encoded size in bits
                double compressionRatio = (double)(originalSize - encodedSize) / originalSize * 100;

                cout << "\nOriginal Size (in bits): " << originalSize << endl;
                cout << "Encoded Size (in bits): " << encodedSize << endl;
                cout << "Compression Ratio: " << compressionRatio << "%" << endl;
                break;
            }

            case 7:
                // Exit the program
                cout << "Exiting the program." << endl;
                return 0;

            default:
                cout << "Invalid choice, please try again." << endl;
        }
    }

    return 0;
}
